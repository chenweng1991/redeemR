
## Internal function for Create_redeemR_model
goodness_of_fit_test <- function(trials,coverage = 30) {
  # Number of trials
  n_trials <- length(trials)
  # Handle possible coverage exceed
  if (max(trials)>coverage){
    coverage <- max(trials)
  }  
  # Observed frequencies
  observed_frequencies <- table(factor(trials, levels = 0:coverage))
  # Single coin model
  total_heads <- sum(trials)
  total_flips <- n_trials * coverage
  p_hat <- total_heads / total_flips
  # Expected frequencies under the single binomial model
  expected_frequencies <- n_trials * dbinom(0:coverage, size = coverage, prob = p_hat)
  # Handle the 0 in expected frequency
  expected_frequencies[expected_frequencies==0]<- 1e-318  
  # Chi-squared test statistic
  chi2_stat <- sum((observed_frequencies - expected_frequencies)^2 / expected_frequencies)
  # p-value from chi-squared distribution with coverage degrees of freedom (coverage + 1 possible outcomes - 1 estimated parameter)
  p_value <- pchisq(chi2_stat, df = coverage, lower.tail = FALSE)
  return(list(chi2_stat = chi2_stat, p_value = p_value))
}

## Internal function, executed by Create_redeemR_model
run_binomial_noise_removal <- function(redeem){
    require(qvalue)
    if ("chi" %in% colnames(redeem@V.fitered)){
        stop("goodness_of_fit_test has been run on this dataset")
    }else{    
        Mtx <- redeem@Cts.Mtx
        stats <- c()
        pvalues <- c()
        for (i in 1:ncol(Mtx)){
            v<- as.integer(redeem@Cts.Mtx[,i])
            pos <- as.numeric(gsub("Variants([0-9]+)[A-Za-z]{2}$", "\\1", colnames(Mtx)))
            cov<-as.integer(as.numeric(redeem@DepthSummary$Pos.MeanCov[pos[i],"meanCov"]))
            res<-goodness_of_fit_test(v,cov)
            stats<-c(stats,res$chi2_stat)
            pvalues<-c(pvalues,res$p_value)
        }
        qvalues <- qvalue(pvalues)$qvalues
        redeem@V.fitered<-merge(redeem@V.fitered,data.frame(Variants=convert_variant(colnames(Mtx)),pvalues=pvalues, qvalues=qvalues, chi=stats),all = T)
        return(redeem)
        }    
}

#' Create_redeemR_model
#'
#' This function is to create redeemR with basic information, modeled by binomial distribution
#' maxctscut is removed, replaced by the modeling, will generate statistics and p value
#' @param VariantsGTSummary simply put GTSummary (Generated by redeemR.read) 
#' @param qualifiedCellCut The minimum median mitochondrial coverage for a qualified cell, default is 10
#' @param OnlyHetero If only consider the heteroplasmy variants, default is T
#' @param VAFcut only use variants with VAF smaller than VAFcut. Default is 1.  We can use smaller value to constrain into only using rare variants
#' @param Cellcut only use variants with at least cellcut cells carry
#' @return redeemR class
#' @export
#' @import Seurat ape phytools phangorn tidytree ggtreeExtra
#' @importFrom ggtree ggtree
Create_redeemR_model<-function(VariantsGTSummary=VariantsGTSummary,qualifiedCellCut=10,VAFcut=1,Cellcut=2){
 if ("edge_trim" %in% names(attributes(VariantsGTSummary))){
        edge_trim <- as.numeric(attr(VariantsGTSummary,"edge_trim"))
    }else{
        edge_trim <- 0
    }
CellMeta<-subset(attr(VariantsGTSummary,"depth")[["Cell.MeanCov"]],meanCov>=qualifiedCellCut)
names(CellMeta)[1]<-"Cell"
VariantsGTSummary.feature<-Vfilter_v4(VariantsGTSummary,Min_Cells = Cellcut, Max_Count_perCell = 1, QualifyCellCut = qualifiedCellCut)
GTsummary.filtered<-subset(VariantsGTSummary,Variants %in% VariantsGTSummary.feature$Variants & Cell %in% CellMeta$Cell)
ob<-new("redeemR")
ob@GTsummary.filtered<-GTsummary.filtered
ob@CellMeta<-CellMeta
ob@V.fitered=VariantsGTSummary.feature
ob@HomoVariants<-attr(VariantsGTSummary.feature,"HomoVariants")
ob@UniqueV<-VariantsGTSummary.feature$Variants
ob@DepthSummary<-attr(VariantsGTSummary,"depth")
ob@para<-c(Threhold=attr(VariantsGTSummary,"thr"),qualifiedCellCut=qualifiedCellCut,VAFcut=VAFcut,Cellcut=Cellcut,edge_trim=edge_trim)
ob@attr<-list(path=attr(VariantsGTSummary,"path"))

if ("combined" %in% names(attributes(VariantsGTSummary))){
    ob@attr <- c(ob@attr,combine_sample=list(combine=attr(VariantsGTSummary,"combined"),suffix=attr(VariantsGTSummary,"suffix")))
}
ob<-Make_matrix(ob,onlyhetero=T)
ob<-run_binomial_noise_removal(ob)
return(ob)
}


#' clean_redeem
#'
#' This function is to clean redeem by filtering both V.fitered and GTsummary.filtered by qvalues
#' 
#' @param ob redeem object
#' @param fdr fdr cutoff, default is 0.05
#' @export
clean_redeem <-function(ob,fdr=0.05){
    ob@V.fitered <- subset(ob@V.fitered,qvalues<=fdr)
    ob@GTsummary.filtered<-subset(ob@GTsummary.filtered, Variants %in% ob@V.fitered$Variants)
    ob<-Make_matrix(ob,onlyhetero=T)
    ob@UniqueV <- ob@V.fitered$Variants
    return(ob)
}


#' clean_redeem_removehotcall
#'
#' This function is to clean redeem by filtering both V.fitered and GTsummary.filtered by qvalues
#' 
#' @param ob redeem object
#' @param hotcall fdr cutoff, default is 0.05
#' @export
clean_redeem_removehot <-function(ob,hotcall= c("310_T_C","9979_G_A","3109_T_C")){
    ob@V.fitered <- subset(ob@V.fitered,!Variants %in% hotcall)
    ob@GTsummary.filtered<-subset(ob@GTsummary.filtered, !Variants %in% hotcall)
    ob<-Make_matrix(ob,onlyhetero=T)
    ob@UniqueV <- ob@V.fitered$Variants
    return(ob)
}


#’ Add_DepthMatrix_filter2
#' Add Filter-2–adjusted depth matrix to a redeemR object
#’
#’ This function reads the “QualifiedTotalCts” matrix from disk (if not already supplied),
#’ applies the Filter-2 adjustment—subtracting counts for UMIs removed by edge trimming
#’ (zeros and unaffected entries remain unchanged)—then reshapes the result into a matrix
#’ matching the dimensions of `object@Cts.Mtx.bi` and stores it in
#’ `object@Cts.Mtx.depth.filter2`.
#’
#’ @param object A \code{redeemR} object
#’ @param QualifiedTotalCts Optional data.frame of the same format as the
#’   “QualifiedTotalCts” file. If \code{NULL}, it will be read from
#’   \code{file.path(object@attr$path, "QualifiedTotalCts")}.
#’ @return The input \code{redeemR} object, with
#’   \code{object@Ctx.Mtx.depth.filter2} populated.
#’ @export
Add_DepthMatrix_filter2 <- function(object, QualifiedTotalCts = NULL) {
    # 1. load the table if needed
    if (is.null(QualifiedTotalCts)) {
        QualifiedTotalCts<-read.table(paste(object@attr$path,"/QualifiedTotalCts",sep=""))
    }
    colnames(QualifiedTotalCts)<-c("Cell","Pos","T","LS","S","VS")
    message("[Step 1] QualifiedTotalCts loaded with columns: ", paste(colnames(QualifiedTotalCts), collapse = ", "))
    
    # 2. build variant→pos dictionary
    Dic<-gsub("Variants","",colnames(object@Cts.Mtx.bi)) %>% substr(.,1,nchar(.)-2) %>% as.integer %>% data.frame(Variants=colnames(object@Cts.Mtx.bi),Pos=.)
    message("[Step 2] Dic built with ", nrow(Dic), " entries")

    # 3. subset QualifiedTotalCts for cells and all positions for variants
    QualifiedTotalCts.subset<-subset(QualifiedTotalCts,Cell %in% row.names(object@Cts.Mtx.bi)) %>% merge(.,Dic,by="Pos") %>% .[,c("Cell","Variants",object@para["Threhold"])]
    QualifiedTotalCts.subset_Var1 <- QualifiedTotalCts.subset %>% 
            mutate(Var1=paste(Cell, convert_variant(Variants),sep="_"))        
    message("[Step 3] Subset contains ", nrow(QualifiedTotalCts.subset), " rows")

    # 4. Split into gt vs zero 
    ## -->  _gt is the ones match GTsummary;  _zero are the depth for rest of cell-variant that are zero
    QualifiedTotalCts.subset_Var1_gt   <- QualifiedTotalCts.subset_Var1 %>% filter(Var1 %in% object@GTsummary.filtered$Var1)
    QualifiedTotalCts.subset_Var1_zero <- QualifiedTotalCts.subset_Var1 %>% filter(!Var1 %in% object@GTsummary.filtered$Var1)
    message("[Step 5] gt rows: ", nrow(QualifiedTotalCts.subset_Var1_gt),
          "; zero rows: ", nrow(QualifiedTotalCts.subset_Var1_zero))

    # 5. Adjust the depth for the ones that changed
    QualifiedTotalCts.subset_Var1_gt_constant<- QualifiedTotalCts.subset_Var1_gt %>% left_join(object@GTsummary.filtered[,c("Var1","depth")], by="Var1") %>%
    filter(S == depth)
    QualifiedTotalCts.subset_Var1_gt_adjust_depth<- QualifiedTotalCts.subset_Var1_gt %>% left_join(object@GTsummary.filtered[,c("Var1","depth")], by="Var1") %>%
    filter(S != depth) %>% mutate(S=depth)
    message("[Step 6] constant depth rows: ", nrow(QualifiedTotalCts.subset_Var1_gt_constant),
          "; adjusted depth rows: ", nrow(QualifiedTotalCts.subset_Var1_gt_adjust_depth))

    # 6. Adjust the depth for the ones that changed
    ## Put together the QualifiedTotalCts.subset_filter2_adjusted
    QualifiedTotalCts.subset_filter2_adjusted <- rbind(QualifiedTotalCts.subset_Var1_zero[,1:3],
          QualifiedTotalCts.subset_Var1_gt_constant[,1:3],
          QualifiedTotalCts.subset_Var1_gt_adjust_depth[,1:3])
    message("[Step 7] Final subset has ", nrow(QualifiedTotalCts.subset_filter2_adjusted), " rows")

    ##8. Prepare the Dpethmatrix
    message("[Step 8] Casting to DepthMatrix")
    DepthMatrix<-dcast(QualifiedTotalCts.subset_filter2_adjusted,Cell~Variants) %>% tibble::column_to_rownames("Cell") %>% as.matrix
    if (all(dim(object@Cts.Mtx.bi)==dim(DepthMatrix))){
        message("[Step 9] Assigning DepthMatrix to object@Ctx.Mtx.depth.filter2")
        object@Ctx.Mtx.depth<-DepthMatrix[row.names(object@Cts.Mtx.bi),colnames(object@Cts.Mtx.bi)]
    }else{
        print(dim(object@Cts.Mtx.bi))
        print(dim(DepthMatrix))
        print("Check the input QualifiedTotalCts, the dimension cannot match")
    }
    
    return(object)
}

